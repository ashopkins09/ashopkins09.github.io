<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Liquid Glass + Realistic Bubble Wrap</title>
<style>
  :root{
    --bg: #e6f0ff;
    --glass-border: rgba(255,255,255,0.25);
    --accent: #5f9bff;
    --bubble-size: 48px;
    --gap: 12px;
  }

  html,body{
    height:100%;
    margin:0;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: linear-gradient(180deg, #dff0ff 0%, #f7fbff 100%);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  /* layout */
  .page{
    min-height:100vh;
    position:relative;
    display:grid;
    place-items:center;
    overflow:hidden;
  }

  /* Bubble-wrap area covers entire page */
  #bubble-wrap{
    position:absolute;
    inset:0;
    display:grid;
    /* columns are set dynamically from JS */
    gap: var(--gap);
    padding: 36px 20px;
    box-sizing:border-box;
    z-index:0;
    align-content:start;
    pointer-events:auto;
    user-select:none;
  }

  /* Each grid cell holds one bubble (allows row offsets without interfering with bubble transforms) */
  .cell{
    width: var(--bubble-size);
    height: var(--bubble-size);
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
  }
  /* staggered rows */
  .cell[data-row-offset="1"]{
    transform: translateX(calc((var(--bubble-size) + var(--gap)) / 2));
  }

  /* Bubble button */
  .bubble {
    appearance: none;
    -webkit-appearance:none;
    width: calc(var(--bubble-size) - 4px);
    height: calc(var(--bubble-size) - 4px);
    border-radius:50%;
    border: none;
    padding:0;
    margin:0;
    position:relative; /* required for pseudo-elements */
    background: radial-gradient(circle at 34% 28%,
                rgba(255,255,255,0.95) 0 22%,
                rgba(255,255,255,0.6) 23% 42%,
                rgba(150,180,255,0.22) 43% 62%,
                rgba(100,140,255,0.06) 63% 100%);
    box-shadow: 0 8px 18px rgba(20,40,80,0.12), inset 0 -6px 16px rgba(0,0,0,0.12);
    transition: transform 180ms cubic-bezier(.2,.9,.3,1), box-shadow 180ms, background 180ms;
    cursor: pointer;
    touch-action: none;
    outline: none;
  }

  .bubble:focus{
    box-shadow: 0 8px 22px rgba(20,40,80,0.14), 0 0 0 4px rgba(95,155,255,0.12);
  }

  /* tiny hover/wobble for tactile feel (disabled with reduced-motion) */
  .bubble:hover { transform: translateY(-4px) scale(1.02); }
  @media (prefers-reduced-motion: reduce){
    .bubble, .bubble:hover { transition:none; transform:none; }
  }

  /* Popped bubble - concave dent */
  .bubble.popped {
    background: radial-gradient(circle at 50% 62%,
                rgba(0,0,0,0.28) 0 28%,
                rgba(40,60,100,0.20) 29% 55%,
                rgba(200,220,255,0.06) 56% 100%);
    box-shadow: inset 0 8px 18px rgba(0,0,0,0.46), inset 0 -3px 6px rgba(255,255,255,0.06);
    transform: translateY(2px) scale(1);
    pointer-events: none; /* once popped, don't allow more clicks on it */
  }

  /* small rim highlight / wrinkle to sell the plastic creasing */
  .bubble.popped::after{
    content:"";
    position:absolute;
    inset:6% 8%;
    border-radius:50%;
    box-shadow: inset 0 -6px 10px rgba(255,255,255,0.06), inset 0 6px 8px rgba(0,0,0,0.12);
    opacity:0.85;
    transform: translateY(1px);
    pointer-events:none;
  }

  /* Liquid glass card in center — allow clicks to pass through except for its interactive children */
  .glass-card{
    position:relative;
    z-index:3;
    width:min(980px,92%);
    padding: clamp(16px, 3.2vw, 32px);
    border-radius:16px;
    background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
    border: 1px solid var(--glass-border);
    box-shadow: 0 10px 46px rgba(6,18,40,0.16);
    backdrop-filter: blur(10px) saturate(1.08);
    -webkit-backdrop-filter: blur(10px) saturate(1.08);
    color:#05305b;
    display:flex;
    gap:18px;
    align-items:center;
    pointer-events: none; /* let clicks pass through by default */
  }
  /* Make interactive descendants clickable */
  .glass-card * { pointer-events: auto; }

  .glass-card::before{
    content:"";
    position:absolute;
    inset:0;
    pointer-events:none;
    background: linear-gradient(135deg, rgba(255,255,255,0.22) 0%, rgba(255,255,255,0.03) 40%, rgba(255,255,255,0.06) 100%);
    mix-blend-mode: overlay;
    border-radius:16px;
  }

  .hero { display:flex; align-items:center; gap:14px; width:100%; }
  .hero-text { flex:1 1 auto; }
  h1 { margin:0 0 8px 0; font-size: clamp(20px, 3.6vw, 30px); line-height:1.05; color:#052b54; }
  p.lead { margin:0; color:rgba(5,45,85,0.86); }
  .controls{ margin-top:12px; display:flex; gap:10px; align-items:center; }
  .btn{
    appearance:none; border:none; padding:8px 14px; border-radius:10px; font-weight:600; cursor:pointer;
    background: linear-gradient(180deg,#fff 0%, #f1f7ff 100%); color:#05407a; box-shadow:0 6px 16px rgba(20,40,80,0.06);
  }
  .btn.primary{ background: linear-gradient(180deg,var(--accent) 0%, #2d80ff 100%); color:#fff; box-shadow:0 10px 30px rgba(45,128,255,0.24); }
  .credit{ margin-left:auto; font-size:12px; color:rgba(3,29,56,0.6); white-space:nowrap; }

  .tip{ font-size:13px; color:rgba(3,29,56,0.66); margin-top:8px; }

  @media (max-width:720px){
    :root { --bubble-size: 36px; --gap: 10px; }
    .glass-card { padding:12px; border-radius:12px; }
  }
</style>
</head>
<body>
  <div class="page" id="page">
    <div id="bubble-wrap" aria-hidden="false"></div>

    <main class="glass-card" role="main" aria-labelledby="title">
      <div class="hero">
        <div class="hero-text">
          <h1 id="title">Liquid Glass Home — Pop to Play</h1>
          <p class="lead">Click, drag, or use the keyboard to pop the bubble‑wrap background. Double‑click or press the button to reset.</p>
          <div class="controls" role="group" aria-label="controls">
            <button class="btn primary" id="resetBtn" title="Refill the bubble wrap">Refill bubbles</button>
            <button class="btn" id="shuffleBtn" title="Shuffle layout">Shuffle</button>
            <div class="credit">Made with liquid glass ✨</div>
          </div>
          <div class="tip">Tip: drag across bubbles to pop many at once. Press <kbd>R</kbd> to refill, <kbd>S</kbd> to shuffle.</div>
        </div>

        <div style="width:108px;flex:0 0 108px;display:grid;place-items:center;">
          <svg width="90" height="90" viewBox="0 0 96 96" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <defs>
              <radialGradient id="g" cx="30%" cy="20%">
                <stop offset="0%" stop-color="#fff" stop-opacity="0.95"/>
                <stop offset="45%" stop-color="#cfe8ff" stop-opacity="0.6"/>
                <stop offset="100%" stop-color="#7aa7ff" stop-opacity="0.2"/>
              </radialGradient>
            </defs>
            <circle cx="48" cy="48" r="44" fill="url(#g)" stroke="rgba(255,255,255,0.5)" stroke-width="1.5"/>
            <ellipse cx="36" cy="34" rx="10" ry="6" fill="rgba(255,255,255,0.9)"/>
          </svg>
        </div>
      </div>
    </main>
  </div>

<script>
/* Robust bubble-wrap interaction
   - Creates grid of .cell > button.bubble
   - Click / drag / keyboard to pop
   - Reset (refill) and shuffle
   - Works through the glass card (card children remain interactive)
*/

(function(){
  const wrap = document.getElementById('bubble-wrap');
  const resetBtn = document.getElementById('resetBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const page = document.getElementById('page');

  // read CSS variables (handles media query overrides)
  const rootStyle = getComputedStyle(document.documentElement);
  const settings = {
    bubbleSize: parseFloat(rootStyle.getPropertyValue('--bubble-size')) || 48,
    gap: parseFloat(rootStyle.getPropertyValue('--gap')) || 12,
    popSoundVolume: 0.6
  };

  // audio
  let audioCtx = null;
  function ensureAudio(){
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    return audioCtx;
  }
  function playPopSound(){
    try {
      const ctx = ensureAudio();
      const bufferSize = Math.max(1, Math.floor(ctx.sampleRate * 0.045));
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0;i<bufferSize;i++){
        data[i] = (Math.random()*2-1) * (1 - i/bufferSize);
      }
      const source = ctx.createBufferSource();
      source.buffer = buffer;
      const band = ctx.createBiquadFilter();
      band.type = 'bandpass';
      band.frequency.value = 1100 + Math.random()*900;
      band.Q.value = 1.0;
      const gain = ctx.createGain();
      gain.gain.value = settings.popSoundVolume;
      source.connect(band);
      band.connect(gain);
      gain.connect(ctx.destination);
      const now = ctx.currentTime;
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(settings.popSoundVolume, now + 0.006);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.05);
      source.start(now);
      source.stop(now + 0.06);
    } catch (err) {
      // ignore audio errors (autoplay restrictions, etc.)
      // console.warn(err);
    }
  }

  // build grid to fill viewport
  function buildGrid(){
    // refresh settings (in case of resize & CSS media query changes)
    const rootStyle2 = getComputedStyle(document.documentElement);
    settings.bubbleSize = parseFloat(rootStyle2.getPropertyValue('--bubble-size')) || settings.bubbleSize;
    settings.gap = parseFloat(rootStyle2.getPropertyValue('--gap')) || settings.gap;

    wrap.innerHTML = '';
    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);

    // compute columns/rows accounting for gap
    const unit = settings.bubbleSize + settings.gap;
    const cols = Math.max(6, Math.floor((vw + settings.gap) / unit));
    const rows = Math.max(4, Math.ceil((vh + settings.gap) / unit) + 1);

    // set CSS grid template columns to fixed bubble widths so layout is stable
    wrap.style.gridTemplateColumns = `repeat(${cols}, ${settings.bubbleSize}px)`;
    wrap.style.gridAutoRows = `${settings.bubbleSize}px`;
    wrap.style.gap = `${settings.gap}px`;

    for (let r=0;r<rows;r++){
      const offset = (r % 2 === 1); // stagger odd rows
      for (let c=0;c<cols;c++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.row = r;
        if (offset) cell.dataset.rowOffset = '1';

        const bubble = document.createElement('button');
        bubble.type = 'button';
        bubble.className = 'bubble';
        bubble.setAttribute('aria-pressed','false');
        bubble.setAttribute('title','bubble');
        bubble.tabIndex = 0;

        // keyboard interaction per-bubble
        bubble.addEventListener('keydown', (ev) => {
          if (ev.key === ' ' || ev.key === 'Enter') {
            ev.preventDefault();
            popBubble(bubble, true);
          }
        });

        cell.appendChild(bubble);
        wrap.appendChild(cell);
      }
    }
  }

  // pop a bubble element (idempotent)
  function popBubble(el, playSound=true){
    if (!el || !el.classList) return;
    if (el.classList.contains('popped')) return;
    el.classList.add('popped');
    el.setAttribute('aria-pressed','true');
    if (playSound) {
      try { if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); } catch(e){}
      playPopSound();
    }
  }

  // refill
  function refill(){
    wrap.querySelectorAll('.bubble.popped').forEach(b => {
      b.classList.remove('popped');
      b.setAttribute('aria-pressed','false');
      // gentle reinflate animation
      b.animate([
        { transform: 'scale(0.96)', opacity: 0.9 },
        { transform: 'scale(1)', opacity: 1 }
      ], { duration: 220, easing: 'cubic-bezier(.2,.9,.3,1)' });
    });
  }

  // shuffle row offsets for visual variety
  function shuffle(){
    const rows = [...new Set(Array.from(wrap.children).map(c => c.dataset.row))];
    rows.forEach(r => {
      const offset = Math.random() > 0.5;
      wrap.querySelectorAll(`.cell[data-row="${r}"]`).forEach(cell => {
        if (offset) cell.dataset.rowOffset = '1';
        else cell.removeAttribute('data-row-offset');
      });
    });
    // playful jostle sound
    for (let i=0;i<6;i++){
      setTimeout(() => playPopSound(), i*50);
    }
  }

  // pointer interactions (global so dragging works anywhere)
  let pointerDown = false;
  let lastPoint = {x:0,y:0};
  let raf = null;

  function handlePopAtPoint(x,y){
    const el = document.elementFromPoint(x,y);
    if (!el) return;
    // if the element is a bubble button — pop it
    if (el.classList && el.classList.contains('bubble')) {
      popBubble(el, true);
    } else {
      // sometimes pointer is on the .cell wrapper; find descendant bubble
      const bubble = el.closest && el.closest('.cell') && el.closest('.cell').querySelector('.bubble');
      if (bubble) popBubble(bubble, true);
    }
  }

  document.addEventListener('pointerdown', (e) => {
    // if clicking an input or non-bubble interactive element (controls), don't treat as pop-start
    const interactive = e.target.closest('button, a, input, textarea, select, label');
    // allow starting drags from controls to still pop (optional). If you want to prevent, uncomment the next line:
    // if (interactive && !e.target.classList.contains('bubble')) return;
    pointerDown = true;
    lastPoint.x = e.clientX;
    lastPoint.y = e.clientY;
    handlePopAtPoint(lastPoint.x, lastPoint.y);
    // ensure audio context is resumed on first user gesture
    try { if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); } catch(e){}
  }, {passive:true});

  document.addEventListener('pointerup', () => { pointerDown = false; });

  document.addEventListener('pointermove', (e) => {
    lastPoint.x = e.clientX;
    lastPoint.y = e.clientY;
    if (!pointerDown) return;
    if (raf) return;
    raf = requestAnimationFrame(() => {
      handlePopAtPoint(lastPoint.x, lastPoint.y);
      raf = null;
    });
  }, {passive:true});

  // keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'r') { refill(); }
    if (e.key.toLowerCase() === 's') { shuffle(); }
  });

  // reset / shuffle buttons
  resetBtn.addEventListener('click', (e) => { e.stopPropagation(); refill(); });
  shuffleBtn.addEventListener('click', (e) => { e.stopPropagation(); shuffle(); });

  // double-click anywhere to reset
  page.addEventListener('dblclick', (e) => { refill(); });

  // responsive rebuild
  let resizeTimer = null;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => buildGrid(), 150);
  });

  // initial build
  buildGrid();

  // try to create audio context on first gesture to satisfy browser policies
  document.addEventListener('pointerdown', function resumeAudioOnce(){
    try {
      ensureAudio();
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    } catch(e){}
    document.removeEventListener('pointerdown', resumeAudioOnce);
  }, { once: true });

})();
</script>
</body>
</html>
